
# Java 笔记

**Linux环境配置Jdk环境**

Jdk:/usr/local/java/jdk1.8

`rpm -qa | grep jdk`

`yum -y remove java-1.4.2-gcj-compat-1.4.2.0-40jpp.115`

`vi /etc/profile`

`export JAVA_HOME=/usr/java/jdk-1.6.0_22-fcs`

`export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib`

`export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin`

`source /etc/profile`

**Window环境配置Jdk环境**

1.安装JDK.

2.新建JAVA_HOME变量,变量值填写jdk的安装目录.

3.新建CLASSPATH变量,变量值填写.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar(注意最前面有一点).

4.寻找Path变量→编辑,在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;

# &和&&的区别

1.&&会出现短路,第一个表达式为false,则不继续后面表达式的运算;只能操作boolean类型数据.
2.&不会出现短路,将整个表达式都运算,既可以操作boolean数据还可以操作数.

# 标示符命名规则

由数字(0-9),大小写英文字母,以及_和$组成;不能以数字开头;不能使用关键字来自定义命名.

# 数据类型

基本数据类型(4类8种):
整数类型：byte、short、int、long

浮点数类型：float、double

字符类型：char

布尔类型：boolean(ture false)

引用数据类型:

类;接口;数组

类型转换:

精度从高到低:double > float > long > int > short(char) > byte

自动类型转换:将一个低精度==>高精度

强制类型转换:将一个高精度==>低精度(精度会下降)

# JVM内存结构

5个内存空间:

栈内存:用于存储局部变量,当数据使用完,所占空间会自动释放.

堆内存:数组和对象,通过new建立的实例都存放在堆内存中.

方法区:静态成员,构造函数,常量池,线程池.

本地方法区:window系统占用,每个线程拥有一个PC寄存器,在线程创建时创建,指向下一条指令的地址,执行本地方法时,PC的值为undefined.

寄存器.

**控制参数**

-Xms=设置堆的最小空间大小.

-Xmx=设置堆的最大空间大小.

-XX:NewSize=设置新生代最小空间大小.

-XX:MaxNewSize=设置新生代最大空间大小.

-XX:PermSize=设置永久代最小空间大小.

-XX:MaxPermSize=设置永久代最大空间大小.

-Xss=设置每个线程的堆栈大小.

# 面向对象

概述:面向对象是相对于面向过程而言的,面向过程强调的是功能,面向对象强调的是将功能封装进对象,强调具备功能的对象.

特征:

封装(隐藏对象的属性和实现细节,仅对外提供公共访问方式);

继承(多个类中存在相同属性和行为时,将这些内容抽取到单独一个类中,那么多个类无需再定义这些属性和行为,只要继承那个类即可);

多态(一个对象在程序不同运行时刻代表的多种状态,父类或者接口的引用指向子类对象).
Fu f = new Zi();
A:成员变量
编译看左边，运行看左边
B:成员方法 
编译看左边，运行看右边
C:静态方法
编译看左边，运行看左边

#类和对象

类:对现实世界中某类事物的描述,是抽象的,概念上的定义.
对象:事物具体存在的个体.

# 重载

概念:在同一个类中,允许存在一个以上的同名函数,只要它们的参数个数或者参数类型不同即可.

# 重写

概念:在具有父子关系的两个类当中,父类和子类各有一个函数,这两个函数的定义(返回值类型,函数名,参数列表)完全相同.

# 函数

定义:函数就是定义在类中的具有特定功能的一段独立小程序,也是方法.

特点:定义函数可以将功能代码进行封装;便于对该功能进行复用;函数只有被调用才会被执行;函数的出现提高了代码的复用性;对于函数没有具体返回值的情况，返回值类型用关键字void表示;那么该函数中的return语句如果在最后一行可以省略不写.

# 数组

概念:同一种数据类型的集合.

# 成员变量和局部变量的区别

1.作用域

成员变量:针对整个类有效.
局部变量:只在某个范围内有效(一般指的就是方法,语句体内).

2.存储位置

成员变量:随着对象的创建而存在,随着对象的消失而消失,存储在堆内存中.
局部变量:在方法被调用,或者语句被执行的时候存在,存储在栈内存中.
当方法调用完,或者语句结束后,就自动释放.

3.初始值

成员变量:有默认初始值.
局部变量:没有默认初始值,使用前必须赋值.

# static关键字

static:静态的意思,用来修饰成员变量和成员函数.

静态的特点:随着类的加载而加载;优先于对象存在;对所有对象共享;可以被类名直接调用;
静态方法只能访问静态成员;静态方法中不能使用this,super关键字.

**静态变量和成员变量的区别**

调用方式:

静态变量也称为类变量,可以直接通过类名调用,也可以通过对象名调用,这个变量属于类.
成员变量也称为实例变量,只能通过对象名调用,这个变量属于对象.

存储位置:

静态变量存储在方法区长中的静态区.
成员变量存储在堆内存.

生命周期:

静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。
成员变量随着对象的创建而存在，随着对象的消失而消失。

与对象的相关性:

静态变量是所有对象共享的数据。
成员变量是每个对象所特有的数据。

静态的优点和弊端

优点:对对象的共享数据进行单独空间的存储,节省内存,没有必要每个对象都存储一份可直接被类名调用.
弊端:生命周期过长,随着类的消失而消失访问出现权限,即静态虽好但只能访问静态.

静态代码块:

它只执行一次,它比main还先执行;执行顺序;静态代码块==>构造代码块==>构造方法

# final关键字

final:最终的意思,可以用于修饰类,方法,变量;final修饰的类不能被继承;final修饰的方法不能被重写;final修饰的变量是一个常量,只能被赋值一次;
内部类只能访问被final修饰的局部变量.

# 单例设计模式

饿汉式:当类加载的时候,就创建对象.(常用)

`
class Student {
    private static final Student s = new Student();
    private Student(){}
    public static Student getInstance() {
        return s;
    }
}
`

懒汉式:当使用的使用,才去创建对象.

`
class Student {
    private static final Student s = null;
    private Student() {}
    public static Student getInstance() {
        if (s==null) {
            //线程1就进来了，线程2就进来了。
            s = new Student();
        }
        return s;
    }
}
`

# 抽象类(abstract)

抽象类:该方法称为抽象方法,包含抽象方法的类就是抽象类.

抽象类的特点:
抽象类和抽象方法都要用abstract进行修饰;
抽象类不能被实例化;
抽象类中不一定有抽象方法,但是,有抽象方法的类一定是抽象类.
抽象类中可以有变量,也可以有常量;
抽象类中可以有抽象方法,也可以有非抽象方法;
抽象类是一个类,所以,它有构造方法;
虽然本身不能实例化,但是可以给子类实例化使用.
抽象关键字abstract不可以和private,final,static关键字共存.

# 接口(interface)

接口:一个类中的方法都是抽象的类,类与接口关系用implements表示.

(2)接口的成员特点
A:成员变量
是常量，默认修饰 public static final
B:成员方法
都是抽象的，默认修饰 public abstract

(3)关系
A:类与类的关系
是继承关系。类与类只能单继承，可以多重继承.
B:类和接口的关系
是实现关系。类可以多实现接口.
类在继承一个类的同时，可以实现多个接口.
C:接口和接口的关系
是继承关系。接口可以多继承接口.

(4)接口的特点
A:是对外暴露的规则
B:是功能的扩展
C:接口的出现降低耦合性
耦合(类与类之间的关系)
内聚(类完成功能的能力)
编程规范：低耦合，高内聚
D:接口可以多实现。如：CPU和主板、笔记本的USB插口、插座

**接口和抽象类的区别**

1.抽象类只能被单继承,接口可以多实现,接口的出现避免了多继承的局限性.
2.数据特点:
成员变量:可以是变量,也可以是常量;
成员方法:可以是抽象方法,也可以是非抽象方法;
构造方法:有构造方法;
接口中的数据特点:
成员变量:是常量,默认修饰public static final;
成员方法:都是抽象方法,都有默认修饰public abstract;
构造方法:没有构造方法.
3.抽象类中定义的是继承体系中的共性功能;接口中定义的是继承体系中的扩展功能.
4.抽象类被继承是"is a"关系:xx是yy的一种;接口被实现是"like a"关系:xx像yy的一种.

**==和equals的区别**

==:可以用于比较基本数据类型,比较的就是基本数据类型的值是否相等;也可以用于比较引用数据类型,比较的是对象的地址值是否相等.
equals:只能用于比较引用数据类型的;Object提供的equals是用于比较对象地址值是否相同.

# 异常

异常:程序运行过程中的不正常现象就叫异常.
Error:重大的问题,我们处理不了,也不需要编写代码处理.比如说内存溢出.
Exception:一般性的错误,是需要我们编写代码进行处理的.
RuntimeException:运行时异常,这个我们也不需要处理.

编译时被检测异常:该异常在编译时,如果没有处理(没有抛也没有try),编译失败;该异常被标识,代表这可以被处理.
运行时异常(编译时不检测):在编译时,不需要处理,编译器不检查;该异常的发生,建议不处理,让程序停止,需要对代码进行修正.

**Throwable类**

getMessage():获取异常信息,返回字符串.
toString():获取异常类名和异常信息,返回字符串.
printStackTrace():获取异常类名和异常信息,以及异常出现在程序中的位置,返回值void.

**异常的处理**

try...catch...finally
基本格式：
`try {
    可能出现异常的代码
} catch(异常对象) {
    异常处理代码
} finally {
    释放资源
}`

多个异常同时被捕获的时候,先逮小的,再逮大的.
finally:永远被执行,除非退出jvm,System.exit(0);.

**final,finally,finalize区别**

final:是最终的意思,它可以用于修饰类,成员变量,成员方法;它修饰的类不能被继承,它修饰的变量时常量,它修饰的方法不能被重写.
finally:是异常处理里面的关键字,它其中的代码永远被执行,除非在执行它之前jvm退出,System.exit(0);
finalize:是Object类中的一个方法,它是于垃圾回收器调用的方式.

**throws和throw的区别**

有throws的时候可以没有throw;有throw的时候,如果throw抛的异常是Exception体系,那么必须有throws在方法上声明.
throws用于方法的声明上,其后跟的是异常类名,后面可以跟多个异常类,之间用逗号隔开;throw用于方法体中,其后跟的是一个异常对象名.

# 多线程

进程:正在进行的程序;每一个进程执行都有一个执行顺序,该顺序是一个执行路径,或者叫一个控制单元.
线程:进程内部的一条执行路径或者一个控制单元.

两者的区别:一个进程至少有一个线程;进程在执行过程中拥有独立的内存单元,而多个线程共享内存.

多线程:一个进程中有多个线程,称为多线程.

多线程的优势:解决了多部分同时运行的问题,提高效率.
线程的弊端:线程太多会导致效率的降低,因为线程的执行依靠的是CPU的来回切换.

实现多线程的方法:实现多线程可以通过继承Thread类和实现Runnable接口.

1.继承Thread
定义一个类继承Thread类,复写Thread类中的public void run()方法,将线程的任务代码封装到run方法中直接创建Thread的子类对象,创建线程;调用start()方法开启线程(调用线程的任务run方法),另外可以通过Thread的getName()获取线程的名称.

2.实现Runnable接口
定义一个类,实现Runnable接口,覆盖接口的public void run()的方法,将线程的任务代码封装到run方法中;创建Runnable接口的子类对象将Runnabl接口的子类对象作为参数传递给Thread类的构造函数,创建Thread类对象(原因:线程的任务都封装在Runnable接口子类对象的run方法中,所以要在线程对象创建时就必须明确要运行的任务);调用start()方法,启动线程.

两种方法区别
实现Runnable接口避免了单继承的局限性;继承Thread类线程代码存放在Thread子类的run方法中实现Runnable接口线程代码存放在接口的子类的run方法中,在定义线程时,建议使用实现Runnable接口,因为几乎所有多线程都可以使用这种方式实现.

**start()和run()区别**

调用start方法方可启动线程,而run方法只是thread的一个普通方法,调用run方法不能实现多线程.

**线程的几种状态**

新建:new一个Thread对象或者其子类对象就是创建一个线程,当一个线程对象被创建,但是没有开启,这个时候,只是对象线程对象开辟了内存空间和初始化数据.
就绪:新建的对象调用start方法,就开启了线程,线程就到了就绪状态,在这个状态的线程对象,具有执行资格,没有执行权.
运行:当线程对象获取到了CPU的资源,在这个状态的线程对象,既有执行资格,也有执行权.
冻结:运行过程中的线程由于某些原因(比如wait,sleep),释放了执行资格和执行权,当然,他们可以回到运行状态,只不过,不是直接回到,而是先回到就绪状态.
死亡:当线程对象调用的run方法结束,或者直接调用stop方法,就让线程对象死亡,在内存中变成了垃圾.

**sleep()和wait()的区别**

(1)这两个方法来自不同的类，sleep()来自Thread类，和wait()来自Object类。
sleep():是Thread的静态类方法,谁调用的谁去睡觉,即使在a线程里调用了b的sleep方法,实际上还是a去睡觉,要让b线程睡觉要在b的代码中调用sleep;释放资源不释放锁.
wait():是Object类的非静态方法,释放资源释放锁；
wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用.

**多线程安全问题**

原因:当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源),由于线程的随机性导致一个线程对多条语句,执行了一部分还没执行完,另一个线程抢夺到cpu执行权参与进来执行,此时就导致共享数据发生错误,比如买票例子中打印重票和错票的情况.
解决方法:对多条操作共享数据的语句进行同步,一个线程在执行过程中其他线程不可以参与进来.
















































































