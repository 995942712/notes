
# Java 笔记

**Linux环境配置Jdk环境**

Jdk:/usr/local/java/jdk1.8

`rpm -qa | grep jdk`

`yum -y remove java-1.4.2-gcj-compat-1.4.2.0-40jpp.115`

`vi /etc/profile`

`export JAVA_HOME=/usr/java/jdk-1.6.0_22-fcs`

`export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib:$JAVA_HOME/jre/lib`

`export PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH:$HOME/bin`

`source /etc/profile`

**Window环境配置Jdk环境**

1.安装JDK.

2.新建JAVA_HOME变量,变量值填写jdk的安装目录.

3.新建CLASSPATH变量,变量值填写.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar(注意最前面有一点).

4.寻找Path变量→编辑,在变量值最后输入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;

# &和&&的区别

1.&&会出现短路,第一个表达式为false,则不继续后面表达式的运算;只能操作boolean类型数据.
2.&不会出现短路,将整个表达式都运算,既可以操作boolean数据还可以操作数.

# 标示符命名规则

由数字(0-9),大小写英文字母,以及_和$组成;不能以数字开头;不能使用关键字来自定义命名.

# 数据类型

基本数据类型(4类8种):
整数类型：byte、short、int、long

浮点数类型：float、double

字符类型：char

布尔类型：boolean(ture false)

引用数据类型:

类;接口;数组

类型转换:

精度从高到低:double > float > long > int > short(char) > byte

自动类型转换:将一个低精度==>高精度

强制类型转换:将一个高精度==>低精度(精度会下降)

# JVM内存结构

5个内存空间:

栈内存:用于存储局部变量,当数据使用完,所占空间会自动释放.

堆内存:数组和对象,通过new建立的实例都存放在堆内存中.

方法区:静态成员,构造函数,常量池,线程池.

本地方法区:window系统占用,每个线程拥有一个PC寄存器,在线程创建时创建,指向下一条指令的地址,执行本地方法时,PC的值为undefined.

寄存器.

**控制参数**

-Xms=设置堆的最小空间大小.

-Xmx=设置堆的最大空间大小.

-XX:NewSize=设置新生代最小空间大小.

-XX:MaxNewSize=设置新生代最大空间大小.

-XX:PermSize=设置永久代最小空间大小.

-XX:MaxPermSize=设置永久代最大空间大小.

-Xss=设置每个线程的堆栈大小.

# 面向对象

概述:面向对象是相对于面向过程而言的,面向过程强调的是功能,面向对象强调的是将功能封装进对象,强调具备功能的对象.

特征:

封装(隐藏对象的属性和实现细节,仅对外提供公共访问方式);

继承(多个类中存在相同属性和行为时,将这些内容抽取到单独一个类中,那么多个类无需再定义这些属性和行为,只要继承那个类即可);

多态(一个对象在程序不同运行时刻代表的多种状态,父类或者接口的引用指向子类对象).
Fu f = new Zi();
A:成员变量
编译看左边，运行看左边
B:成员方法 
编译看左边，运行看右边
C:静态方法
编译看左边，运行看左边

# 类和对象

类:对现实世界中某类事物的描述,是抽象的,概念上的定义.
对象:事物具体存在的个体.

# 重载

概念:在同一个类中,允许存在一个以上的同名函数,只要它们的参数个数或者参数类型不同即可.

# 重写

概念:在具有父子关系的两个类当中,父类和子类各有一个函数,这两个函数的定义(返回值类型,函数名,参数列表)完全相同.

# 函数

定义:函数就是定义在类中的具有特定功能的一段独立小程序,也是方法.

特点:定义函数可以将功能代码进行封装;便于对该功能进行复用;函数只有被调用才会被执行;函数的出现提高了代码的复用性;对于函数没有具体返回值的情况，返回值类型用关键字void表示;那么该函数中的return语句如果在最后一行可以省略不写.

# 数组

概念:同一种数据类型的集合.

# 成员变量和局部变量的区别

1.作用域

成员变量:针对整个类有效.
局部变量:只在某个范围内有效(一般指的就是方法,语句体内).

2.存储位置

成员变量:随着对象的创建而存在,随着对象的消失而消失,存储在堆内存中.
局部变量:在方法被调用,或者语句被执行的时候存在,存储在栈内存中.
当方法调用完,或者语句结束后,就自动释放.

3.初始值

成员变量:有默认初始值.
局部变量:没有默认初始值,使用前必须赋值.

# static关键字

static:静态的意思,用来修饰成员变量和成员函数.

静态的特点:随着类的加载而加载;优先于对象存在;对所有对象共享;可以被类名直接调用;
静态方法只能访问静态成员;静态方法中不能使用this,super关键字.

**静态变量和成员变量的区别**

调用方式:

静态变量也称为类变量,可以直接通过类名调用,也可以通过对象名调用,这个变量属于类.
成员变量也称为实例变量,只能通过对象名调用,这个变量属于对象.

存储位置:

静态变量存储在方法区长中的静态区.
成员变量存储在堆内存.

生命周期:

静态变量随着类的加载而存在，随着类的消失而消失。生命周期长。
成员变量随着对象的创建而存在，随着对象的消失而消失。

与对象的相关性:

静态变量是所有对象共享的数据。
成员变量是每个对象所特有的数据。

静态的优点和弊端

优点:对对象的共享数据进行单独空间的存储,节省内存,没有必要每个对象都存储一份可直接被类名调用.
弊端:生命周期过长,随着类的消失而消失访问出现权限,即静态虽好但只能访问静态.

静态代码块:

它只执行一次,它比main还先执行;执行顺序;静态代码块==>构造代码块==>构造方法

# final关键字

final:最终的意思,可以用于修饰类,方法,变量;final修饰的类不能被继承;final修饰的方法不能被重写;final修饰的变量是一个常量,只能被赋值一次;
内部类只能访问被final修饰的局部变量.

# 单例设计模式

饿汉式:当类加载的时候,就创建对象.(常用)

`
class Student {
    private static final Student s = new Student();
    private Student(){}
    public static Student getInstance() {
        return s;
    }
}
`

懒汉式:当使用的使用,才去创建对象.

`
class Student {
    private static final Student s = null;
    private Student() {}
    public static Student getInstance() {
        if (s==null) {
            //线程1就进来了，线程2就进来了。
            s = new Student();
        }
        return s;
    }
}
`

# 抽象类(abstract)

抽象类:该方法称为抽象方法,包含抽象方法的类就是抽象类.

抽象类的特点:
抽象类和抽象方法都要用abstract进行修饰;
抽象类不能被实例化;
抽象类中不一定有抽象方法,但是,有抽象方法的类一定是抽象类.
抽象类中可以有变量,也可以有常量;
抽象类中可以有抽象方法,也可以有非抽象方法;
抽象类是一个类,所以,它有构造方法;
虽然本身不能实例化,但是可以给子类实例化使用.
抽象关键字abstract不可以和private,final,static关键字共存.

# 接口(interface)

接口:一个类中的方法都是抽象的类,类与接口关系用implements表示.

(2)接口的成员特点
A:成员变量
是常量，默认修饰 public static final
B:成员方法
都是抽象的，默认修饰 public abstract

(3)关系
A:类与类的关系
是继承关系。类与类只能单继承，可以多重继承.
B:类和接口的关系
是实现关系。类可以多实现接口.
类在继承一个类的同时，可以实现多个接口.
C:接口和接口的关系
是继承关系。接口可以多继承接口.

(4)接口的特点
A:是对外暴露的规则
B:是功能的扩展
C:接口的出现降低耦合性
耦合(类与类之间的关系)
内聚(类完成功能的能力)
编程规范：低耦合，高内聚
D:接口可以多实现。如：CPU和主板、笔记本的USB插口、插座

**接口和抽象类的区别**

1.抽象类只能被单继承,接口可以多实现,接口的出现避免了多继承的局限性.
2.数据特点:
成员变量:可以是变量,也可以是常量;
成员方法:可以是抽象方法,也可以是非抽象方法;
构造方法:有构造方法;
接口中的数据特点:
成员变量:是常量,默认修饰public static final;
成员方法:都是抽象方法,都有默认修饰public abstract;
构造方法:没有构造方法.
3.抽象类中定义的是继承体系中的共性功能;接口中定义的是继承体系中的扩展功能.
4.抽象类被继承是"is a"关系:xx是yy的一种;接口被实现是"like a"关系:xx像yy的一种.

**==和equals的区别**

==:可以用于比较基本数据类型,比较的就是基本数据类型的值是否相等;也可以用于比较引用数据类型,比较的是对象的地址值是否相等.
equals:只能用于比较引用数据类型的;Object提供的equals是用于比较对象地址值是否相同.

# 异常

异常:程序运行过程中的不正常现象就叫异常.
Error:重大的问题,我们处理不了,也不需要编写代码处理.比如说内存溢出.
Exception:一般性的错误,是需要我们编写代码进行处理的.
RuntimeException:运行时异常,这个我们也不需要处理.

编译时被检测异常:该异常在编译时,如果没有处理(没有抛也没有try),编译失败;该异常被标识,代表这可以被处理.
运行时异常(编译时不检测):在编译时,不需要处理,编译器不检查;该异常的发生,建议不处理,让程序停止,需要对代码进行修正.

**Throwable类**

getMessage():获取异常信息,返回字符串.
toString():获取异常类名和异常信息,返回字符串.
printStackTrace():获取异常类名和异常信息,以及异常出现在程序中的位置,返回值void.

**异常的处理**

try...catch...finally
基本格式：
`try {
    可能出现异常的代码
} catch(异常对象) {
    异常处理代码
} finally {
    释放资源
}`

多个异常同时被捕获的时候,先逮小的,再逮大的.
finally:永远被执行,除非退出jvm,System.exit(0);.

**final,finally,finalize区别**

final:是最终的意思,它可以用于修饰类,成员变量,成员方法;它修饰的类不能被继承,它修饰的变量时常量,它修饰的方法不能被重写.
finally:是异常处理里面的关键字,它其中的代码永远被执行,除非在执行它之前jvm退出,System.exit(0);
finalize:是Object类中的一个方法,它是于垃圾回收器调用的方式.

**throws和throw的区别**

有throws的时候可以没有throw;有throw的时候,如果throw抛的异常是Exception体系,那么必须有throws在方法上声明.
throws用于方法的声明上,其后跟的是异常类名,后面可以跟多个异常类,之间用逗号隔开;throw用于方法体中,其后跟的是一个异常对象名.

# 多线程

进程:正在进行的程序;每一个进程执行都有一个执行顺序,该顺序是一个执行路径,或者叫一个控制单元.
线程:进程内部的一条执行路径或者一个控制单元.

两者的区别:一个进程至少有一个线程;进程在执行过程中拥有独立的内存单元,而多个线程共享内存.

多线程:一个进程中有多个线程,称为多线程.

多线程的优势:解决了多部分同时运行的问题,提高效率.
线程的弊端:线程太多会导致效率的降低,因为线程的执行依靠的是CPU的来回切换.

实现多线程的方法:实现多线程可以通过继承Thread类和实现Runnable接口.

1.继承Thread
定义一个类继承Thread类,复写Thread类中的public void run()方法,将线程的任务代码封装到run方法中直接创建Thread的子类对象,创建线程;调用start()方法开启线程(调用线程的任务run方法),另外可以通过Thread的getName()获取线程的名称.

2.实现Runnable接口
定义一个类,实现Runnable接口,覆盖接口的public void run()的方法,将线程的任务代码封装到run方法中;创建Runnable接口的子类对象将Runnabl接口的子类对象作为参数传递给Thread类的构造函数,创建Thread类对象(原因:线程的任务都封装在Runnable接口子类对象的run方法中,所以要在线程对象创建时就必须明确要运行的任务);调用start()方法,启动线程.

两种方法区别
实现Runnable接口避免了单继承的局限性;继承Thread类线程代码存放在Thread子类的run方法中实现Runnable接口线程代码存放在接口的子类的run方法中,在定义线程时,建议使用实现Runnable接口,因为几乎所有多线程都可以使用这种方式实现.

**start()和run()区别**

调用start方法方可启动线程,而run方法只是thread的一个普通方法,调用run方法不能实现多线程.

**线程的几种状态**

新建:new一个Thread对象或者其子类对象就是创建一个线程,当一个线程对象被创建,但是没有开启,这个时候,只是对象线程对象开辟了内存空间和初始化数据.
就绪:新建的对象调用start方法,就开启了线程,线程就到了就绪状态,在这个状态的线程对象,具有执行资格,没有执行权.
运行:当线程对象获取到了CPU的资源,在这个状态的线程对象,既有执行资格,也有执行权.
冻结:运行过程中的线程由于某些原因(比如wait,sleep),释放了执行资格和执行权,当然,他们可以回到运行状态,只不过,不是直接回到,而是先回到就绪状态.
死亡:当线程对象调用的run方法结束,或者直接调用stop方法,就让线程对象死亡,在内存中变成了垃圾.

**sleep()和wait()的区别**

(1)这两个方法来自不同的类，sleep()来自Thread类，和wait()来自Object类。
sleep():是Thread的静态类方法,谁调用的谁去睡觉,即使在a线程里调用了b的sleep方法,实际上还是a去睡觉,要让b线程睡觉要在b的代码中调用sleep;释放资源不释放锁.
wait():是Object类的非静态方法,释放资源释放锁；
wait,notify和notifyAll只能在同步控制方法或者同步控制块里面使用,而sleep可以在任何地方使用.

**多线程安全问题**

原因:当程序的多条语句在操作线程共享数据时(如买票例子中的票就是共享资源),由于线程的随机性导致一个线程对多条语句,执行了一部分还没执行完,另一个线程抢夺到cpu执行权参与进来执行,此时就导致共享数据发生错误,比如买票例子中打印重票和错票的情况.
解决方法:对多条操作共享数据的语句进行同步,一个线程在执行过程中其他线程不可以参与进来.

锁:是对象,作用是保证线程同步,解决线程安全问题;持有锁的线程可以在同步中执行,没有锁的线程即使获得cpu执行权,也进不去.

同步的前提:必须保证有两个以上线程;必须是多个线程使用同一个锁,即多条语句在操作线程共享数据;必须保证同步中只有一个线程在运行.

同步的好处:同步解决了多线程的安全问题,弊端:多线程都需要判断锁,比较消耗资源.

# 字符串

**String类**

字符串:多个字符组成的一个序列;字符串对象一旦被创建字符串常量值不改变.

**StringBuffer类**

字符串的缓冲区,是一个容器;它和String的区别是缓冲区可变长度的.

**StringBuilder类**

和StringBuffer的功能是一样的,是线程安全的,效率高.

**基本数据类型的对象包装类**

方便操作,用于和字符串进行相互转换.

byte    ==> Byte
short   ==> Short
int     ==> Integer
long    ==> Long
float   ==> Float
double  ==> Double
boolean ==> Boolean
char    ==> Character

# 集合

集合就是对对象进行存储最常用的一种方式.

数组和集合区别
数组长度固定,而集合长度是可变的;数组值可以存储对象,还可以存储基本数据类型,而集合只能存储对象,可以存储不同类型的对象.

Collection:顶层接口

**List集合**

列表,元素是有序的,可以有重复元素,可以有null元素

ArrayList(JDK1.2):底层是数组数据结构,特点是查询速度快,但是增删速度稍慢,因为当元素多时,增删一个元素则所有元素的角标都得改变,线程不同步,默认长度是10,当超过长度时,按50%延长集合长度.

LinkedList(JDK1.2):底层链表数据结构,查询速度慢,因为每个元素只知道前面一个元素,但增删速度快,因为元素再多,增删一个,只要让其前后的元素重新相连即可,线程是不同步的.

Vector(JDK1.0):底层数组数据结构.特点是查询和增删速度都很慢,默认长度是10,当超过长度时,按100%延长集合长度,线程同步.

**Set集合**

元素是无序的,元素不可以重复,可以有null元素.

HashSet(JDK1.2):底层数据结构是哈希表、存取速度快、元素唯一、线程不同步.
保证性元素唯一的原理:先判断元素的hashCode值是否相同,再判断两元素的equals方法是否为true(往HashSet里面存的自定义元素要复写hashCode和equals方法,以保证元素的唯一性)

TreeSet:底层数据结构式二叉树,可以对Set集合中的元素进行排序,元素有序、线程不同步.
保证元素唯一性的依据:compareTo方法return 0.

**Map集合**

顶层接口,该集合存储的是键值对,而且键是唯一的,Map和Set很像,Set集合底层就是使用了Map集合;Map集合没有迭代器,要取出元素必须先将Map集合转换成Set集合才能遍历元素.

HashTable(JDK1.0):底层是哈希表数据结构,不可以使用null键和null值,线程同步,效率低.
保证元素唯一性的依据:用作键的对象必须实现hashCode和equals方法.

HashMap(JDK1.2):底层是哈希表数据结构,允许使用null键和null值,线程不同步,效率高.
保证性元素唯一的原理:先判断元素的hashCode值是否相同,再判断两元素的equals方法是否为true(往HashSet里面存的自定义元素要复写hashCode和equals方法,以保证元素的唯一性)

Map集合没有迭代器,以下是Map的两种取出方式:
1.Set<K> keySet();返回此映射中包含的键的Set视图,将Map集合中所有的键存入Set集合,然后再通过Set集合的迭代器取出所有的键,再根据get方法获取每个键的值.

`Map<String, Integer> map = new HashMap<String, Integer>();
Set<String> keySet = map.keySet();
Iterator<String> it = keySet.iterator();
while (it.hasNext()) {
    String keyString = it.next();
    System.out.println(keyString+"-"+map.get(keyString));
}`

2.Set<Map.Entry<K,V>> entrySet();返回此映射中包含的映射关系的Set视图,将Map集合中的映射关系存入到Set集合中,这个映射关系的数据类型是Map.entry,再通过Map.Entry类的方法再要取出关系里面的键和值.

`Map<String, String> map = new HashMap<String, String>();
Set<Map.Entry<String, String>> entrySet = map.entrySet();
Iterator<Map.Entry<String, String>> it = entrySet.iterator();
while (it.hasNext()) {
    Map.Entry<String, String> entry = it.next();
    String key = entry.getKey();
    String value = entry.getValue();
}`

**Map集合和Collection集合的区别**

1.Map中一次存储是键值对;Collection中一次存储是单个元素.
2.Map的存储使用的put方法;Collection存储使用的是add方法.
3.Map集合没有迭代器,Map的取出,是将Map转成Set,在使用迭代器取出;Collection取出,使用就是迭代器.
4.如果对象很多,必须使用集合存储;如果元素存在着映射关系,可以优先考虑使用Map存储或者用数组;如果没有映射关系,可以使用Collection存储.

**迭代器(Iterator)**

迭代器就是取出集合元素的方式.
`public interface Iterator<E> {
    boolean hasNext();//判断是否存在下一个对象元素
    E next();//获取下一个元素
    void remove();//移除元素
}`

**堆栈和队列**

堆栈:先进后出,比如杯子里的水.
队列:先进先出,比如水管的水.

# 泛型

泛型:是一个类型安全机制,JDK1.5后出现了泛型,用于解决集合框架的安全问题;泛型定义格式通过<>来定义要操作的引用数据类型,如ArrayList<String> al = new ArrayList<String>;
两种泛型限定,向上限定:? extends E;E可以接收E类型或者E的子类;向下限定:? super E;E可以接收E类型或者E的父类.

# IO流

IO流概述:用来处理设备(硬盘，控制台，内存)间的数据;java中对数据的操作都是通过流的方式;java用于操作流的类都在io包中;按照流操作的数据的类型不同:分为字节流和字符流,字符流是为了方便中文的操作而来的;按照流的流向不同分为:输入流,输出流.

**IO流常用基类**

字节流

输出字节流:OutputStream(字节写入流抽象类),FileOutputStream(字节写入流),BufferedOutputStream(字节写入流缓冲区),PrintStream(打印流).
输入字节流:InputStream(字节读取流抽象类),FileInputStream(字节读取流),BufferedInputStream(字节读取流缓冲区).

字符流

输出字符流:Writer(字符写入流的抽象);FileWriter(字符写入流);BufferedWriter(字符写入流缓冲区);OutputStreamWriter(字符通向字节的转换流(涉及键盘录入时用));OutputStreamWriter(打印流，可处理各种类型的数据).
输入字符流:Reader(字符读取流的抽象类);FileReader(字符读取流);LineNumberReader(跟踪行号的缓冲字符读取流);BufferedReader(字符读取流缓冲区);InputStreamReader(字节通向字符的转换流(涉及键盘录入时用)).

**流操作的规律**

1.先明确源和目的
源:文本(用Reader),字节(用InputStream).
目的:文本(用Writer),字节(用OutputStream).

2.明确是不是纯文本
是:用字符流.
不是:用字节流.

3.明确流体系后,通过设备来明确具体使用哪个流对象
源设备:键盘(System.in),硬盘(文件流File),内存(数组流ArrayStream).
目的设备:键盘(System.out),硬盘(文件流File),内存(数组流ArrayStream).

# 网络编程

**网络编程概述**

网络模型:OSI参考模型,TCP/IP参考模型.

网络通讯要素:IP地址,端口号,传输协议

计算机网络:是指将地理位置不同的具有独立功能的多台计算机及其外部设备,通过通信线路连接起来,在网络操作系统,网络管理软件及网络通信协议的管理和协调下,实现资源共享和信息传递的计算机系统.

IP地址:IP地址 = 网络号码+主机地址
A类IP地址:第一段号码为网络号码,剩下的三段号码为本地计算机的号码.
B类IP地址:前二段号码为网络号码,剩下的二段号码为本地计算机的号码.
C类IP地址:前三段号码为网络号码,剩下的一段号码为本地计算机的号码.

A类:1.0.0.1 ==> 127.255.255.254;10.X.X.X是私有地址(私有地址就是在互联网上不使用,而被用在局域网络中的地址);127.X.X.X是保留地址,用做循环测试用的.
B类:128.0.0.1 ==> 191.255.255.254;172.16.0.0 ==> 172.31.255.255是私有地址;169.254.X.X是保留地址.
C类:192.0.0.1 ==> 223.255.255.254;192.168.X.X是私有地址;
D类:224.0.0.1 ==> 239.255.255.254;
E类:240.0.0.1 ==> 247.255.255.254;

各种网络分类方式
按网络覆盖范围划分:局域网(几米至10公里以内),城域网(10~100公里),广域网(几百公里到几千公里),国际互联网.
按网络拓扑结构划分:总线型网络,星形网络,环型网络,树状网络,混合型网络.
按传输介质划分:有线网,无线网.
按网络使用性质划分:公用网,专用网.

网络模型:OSI模型,应用层,表示层,会话层,传输层,网络层,数据连接层,物理层.

TCP/IP模型:应用层,传输层,网际层,主机至网络层.



